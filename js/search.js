// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Configuring",
      "url": "/sharry/doc/configure",
      "content": "{{ page.title }} Sharry’s executable can take one argument – a configuration file. If that is not given, the defaults are used. The config file overrides default values, so only values that differ from the defaults are necessary to specify. File Format The format of the configuration files can be HOCON, JSON or whatever the used config library understands. The default values below are in HOCON format, which is recommended, since it allows comments and has some advanced features. Please refer to their documentation for more on this. Important Config Options The configuration for the REST server is below sharry.restserver. JDBC This configures the connection to the database. By default, a H2 database in the current /tmp directory is configured. This will create the database on demand in this directory. The config looks like this: sharry.restserver.backend.jdbc { url = ... user = ... password = ... } The url is the connection to the database. It must start with jdbc, followed by name of the database. The rest is specific to the database used: it is either a path to a file for H2 or a host/database url for MariaDB and PostgreSQL. When using H2, the user is sa, the password can be empty and the url must include these options: ;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE Examples PostgreSQL: url = \"jdbc:postgresql://localhost:5432/sharrydb\" MariaDB: url = \"jdbc:mariadb://localhost:3306/sharrydb\" H2 url = \"jdbc:h2:///path/to/a/file.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" Database Checks The setting database-domain-checks is used when inspecting errors that happen when uploading files. It allows to translate database error messages into a message that is presented to the end user. Please see this issue for more information and motivation. The example provided is this: sharry.restserver.backend.share { # Allows additional database checks to be translated into some # meaningful message to the user. # # This config is used when inspecting database error messages. # If the error message from the database contains the defined # `native` part, then the server returns a 422 with the error # messages given here as `message`. # # See issue https://github.com/eikek/sharry/issues/255 – the # example is a virus check via a postgresql extension \"snakeoil\". database-domain-checks = [ # Example: This message originates from postgres with an # enabled snakeoil extension. This extension allows to virus # check byte arrays. It must be setup such that the `bytea` # type of the filechunk table is changed to the type # `safe_bytea`: # # CREATE EXTENSION pg_snakeoil; # CREATE DOMAIN public.safe_bytea as bytea CHECK (not so_is_infected(value)); # ALTER TABLE public.filechunk ALTER COLUMN chunkdata TYPE safe_bytea; { enabled = false native = \"domain safe_bytea violates check constraint\" message = \"The uploaded file contains a virus!\" } ] } Example for Snakeoil The extension snakeoil for PostgreSQL allows to check uploaded binary data for viruses. In order to use this, you need to change the data type for the binary files. This must be applied after sharry has started at least once to initialize its database! The following steps must be done manually: install pg_snakeoil - e.g. on ubuntu systems package: postgresql-12-snakeoil execute the following sql commands on the sharry postgres database: CREATE EXTENSION pg_snakeoil; CREATE DOMAIN public.safe_bytea as bytea check (not so_is_infected(value)); ALTER TABLE public.filechunk ALTER COLUMN chunkdata TYPE safe_bytea; Then add the above setting into your config file. Test files can be found here. Bind The host and port the http server binds to. sharry.restserver.bind { address = localhost port = 9090 } By default, it binds to localhost and some predefined port. Base-url The base url is an important setting that defines the URL where sharry can be reached (the external url). The REST server uses it to create absolute urls and to configure the authenication cookie. These URLs are sent to the client, so they must resolve back to the sharry server. If you see “network error” error messages in the browser, then this setting is probably not correct. By default it is set to http://localhost:9090. If you leave it at localhost, then sharry uses the request to obtain the real external url dynamically by inspecting http headers and finally falling back to the bind.address|port. However, if you have a single external url, it is recommended to set this here. Examples sharry.restserver.base-url = \"https://sharry.example.com\" Registration Options This defines if and how new users can create accounts. There are 3 options: closed no new user can sign up open new users can sign up invite new users can sign up but require an invitation key sharry.restserver.backend.signup { mode = \"open\" # If mode == 'invite', a password must be provided to generate # invitation keys. It must not be empty. invite-password = \"\" # If mode == 'invite', this is the period an invitation token is # considered valid. invite-time = \"3 days\" } The mode invite is intended to open the application only to some users. An admin user can create invitation keys and distribute them to the desired people. While the user must be admin, it is also necessary to provide the invite-password. The idea is that only the person who installs sharry knows this. If it is not set (must be non-empty), then invitation won’t work. New invitation keys can be generated from within the web application or via REST calls (using curl, for example). curl -X POST -H 'Sharry-Auth: {{apikey}}' -d '{\"password\":\"blabla\"}' \"http://localhost:7880/api/v1/open/signup/newinvite\" Authentication The initial authentication will generate an authentication token which is valid for some time. Subsequent calls to secured routes can use this token. The token can be given as a normal http header or via a cookie header. The following options configure this token: sharry.restserver.backend.auth { server-secret = \"hex:caffee\" # or \"b64:Y2FmZmVlCg==\" session-valid = \"8 minutes\" } The server-secret is used to sign the token. If multiple REST servers are deployed, all must share the same server secret. Otherwise tokens from one instance are not valid on another instance. The secret can be given as Base64 encoded string or in hex form. Use the prefix hex: and b64:, respectively. If these prefixes are missing, the string’s utf8 bytes are used. The session-valid deterimens how long a token is valid. This can be just some minutes, the web application obtains new ones periodically. So a rather short time is recommended. The interval the webapp retrieves a new token can be configured, too. It must be at least 30s below the session-valid time. sharry.restserver.webapp { auth-renewal = \"4 minutes\" } Login Modules Login modules are used to initially authenticate a user given some credentials. There are some modules that take a username/password pair and hand it to an external service or program for verification. If valid, sharry creates an account transparently. Then there is the oauth setting which supports authentication via OAuth using “OAuth Code Flow”. All login modules can be enabled/disabled and have an order property that defines the order the login modules are tried. The modules are tried in the specified order until one gives a response. Fixed This is a simple login module for bootstrapping. It defines an admin account using the supplied username and password (plain text) from the config file. fixed { enabled = false user = \"admin\" password = \"admin\" order = 10 } It is disabled by default. If the given username doesn’t match the configured username this login module is skipped and the next is tried. Http The http login module issues a http request with the username/password pair as payload. The response status code determines valid authentication. http { enabled = false url = \"{% raw %}http://localhost:1234/auth?user={{user}}&amp;password={{pass}}{% endraw %}\" method = \"POST\" body = \"\" content-type = \"\" order = 20 } If the method is POST, the body is sent as specified using the given content type. The body and url are processed before as mustache templates, where {% raw %}{{user}}{% endraw %} and {% raw %}{{pass}}{% endraw %} are replaced by their actual values. For other requests than POST, the body is ignored. Http Basic The http-basic login module issues a http request with an Authorization header against some configured url. The header uses the Basic scheme to transport the username/password pair. http-basic { enabled = false url = \"http://somehost:2345/path\" method = \"GET\" order = 30 } If the response is successful (in 2xx), the user is authenticated. Command Allows to validate a username/password pair using some external system command. This is the most flexible approach. command { enabled = false program = [ \"/path/to/someprogram\" \"{% raw %}{{login}}{% endraw %}\" \"{% raw %}{{pass}}{% endraw %}\" ] # the return code to consider successful verification success = 0 order = 30 } The return code of the command is used to determine valid authentication. The program value is an array where the first item is the path to the program and subsequent elements define its arguments. All arguments are processed as a mustache template and variables {% raw %}{{user}}{% endraw %} and {% raw %}{{pass}}{% endraw %} are replaced by their actual values. Internal The internal login module simply authenticates against the sharry database. If it is disabled, you should disable signup, too, because those user won’t be authenticated. OAuth There is now an option to authenticate using a external provider supporting the OAuth “code flow”. There are two examples in the config file for Github and Google. I tried to generalise it as much as possible, but (it seems to me) OAuth is not really a protocol, every provider may choose to do it little differently. The oauth login module can be configured with multiple such providers. Here is an example: oauth = [ { enabled = false id = \"github\" name = \"Github\" icon = \"fab fa-github\" authorize-url = \"https://github.com/login/oauth/authorize\" token-url = \"https://github.com/login/oauth/access_token\" user-url = \"https://api.github.com/user\" user-id-key = \"login\" client-id = \"&lt;your client id&gt;\" client-secret = \"&lt;your client secret&gt;\" } ] Each such entry in the array results in a button on the login screen. Here is how it roughly works: If a user clicks this button, it reaches a specific url in sharry. Sharry will read the corresponding config entry and redirect to the provider adding all the necessary details. The user then authenticates at the provider, which redirects back to sharry – so this method only works if sharry is publicly available, obviously. Then sharry does one more request to turn the code from the redirect into a different code. And then it tries to get the account name. Let’s go through the config values of one entry: enabled: allows to disable this entry without removing it from the file. id: the id that is used in the url behind the button on the login screen. It is also used to amend the account name. name: The name rendered as button text. icon: a fontawesome (free) icon name for the button authorize-url this is the URL of the provider where sharry redirects to at first, attaching client_id and the redirect uri back to sharry. token-url: The url to the provdier where the response from the authorize-url can be turned into a token. user-url: The url to the provider that retrieves the user information given a token as obtained from token-url. user-id-key: Now it get’s a bit hairy…. The protocol doesn’t define (afaik) a common way how to exchange user data. So google does it different from github. Sharry supports JSON responses only and uses the value of user-id-key to lookup a value in that response structure. For example, the github response is a simple JSON object, where the login name is at field login. The path must evaluate to a string. This value is used for the new account inside sharry. client-id and client-secret These are provider specific values that you need to obtain there. With github, for example, you register a new “app” which generates these values. Once sharry gets the account name, it creates a new account (if it not exists already) using the account name from the provider amended with @&lt;id&gt;. I only tested this with github and google, I would appreciate any information on how it works with other providers. Cleanup Sharry has a periodic cleanup job that will delete ‘invalid’ resources. This cleanup job runs in the backend and is triggered by a timer every interval as defined in the cleanup block. It cleans up the following resources: Expired, published shares and their files are removed once the expiration datetime is older than invalid-age defined in the cleanup block. Expired invites are removed based on the invite-time from the signup block. Orphaned files are removed. However, orphaned files should not happen as long as all shares and files are maintained by only sharry and not any external modifications. Default Config {% include server.conf %} Logging By default, sharry logs to stdout. This works well, when managed by systemd or other inits. Logging is done by logback. Please refer to its documentation for how to configure logging. If you created your logback config file, it can be added as argument to the executable using this syntax: /path/to/sharry -Dlogback.configurationFile=/path/to/your/logging-config-file To get started, the default config looks like this: &lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;withJansi&gt;true&lt;/withJansi&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %highlight(%-5level) %cyan(%logger{15}) - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=\"sharry\" level=\"debug\" /&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; The &lt;root level=\"INFO\"&gt; means, that only log statements with level “INFO” will be printed. But the &lt;logger name=\"sharry\" level=\"debug\"&gt; above says, that for loggers with name “sharry” statements from level “DEBUG” on will be printed, too."
    } ,    
    {
      "title": "Development",
      "url": "/sharry/doc/dev",
      "content": "{{ page.title }} Contribution Guide Lines Contribution guide lines may be found here. Building Clone the repository using git. git clone https://github.com/eikek/sharry Install Elm and Sbt, which is used to build the application. Start sbt in the source root and run inside the sbt shell: make to compile all sources (Elm + Scala) make-zip to create zip packages make-deb to create debian packages make-pkg to run a clean compile and create both packages The zip file can be found afterwards in: modules/restserver/target/universal/ The deb file is in modules/restserver/target/ Starting Servers with reStart When developing, it’s very convenient to use the revolver sbt plugin. Start the sbt console and then run: sbt:sharry-root&gt; restserver/reStart This starts a REST server. Prefixing the commads with ~, results in recompile+restart once a source file is modified. Note that with current sbt the revolver plugin will not restart the server if elm files are changed. But this is not really necessary: just run a second sbt shell with ~ compile and sbt will compile all elm files on change and the final js file is immediately available. Only a browser refresh is necessary to load the new web app. Custom config file The sbt build is setup such that a file local/dev.conf (from the root of the source tree) is picked up as config file, if it exists. So you can create a custom config file for development. For example, a custom database for development may be setup this way: #jdbcurl = \"jdbc:h2:///home/dev/workspace/projects/sharry/local/sharry-demo.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" #jdbcurl = \"jdbc:mariadb://localhost:3306/sharrydev\" jdbcurl = \"jdbc:postgresql://localhost:5432/sharrydev\" sharry.restserver { backend { jdbc { url = ${jdbcurl} user = \"dev\" password = \"dev\" } } } Nix Expressions The directory /nix contains nix expressions to install sharry via the nix package manager and to integrate it into NixOS as a system service. Testing NixOS Modules The modules can be build by building the configuration-test.nix file together with some nixpkgs version. For example: nixos-rebuild build-vm -I nixos-config=./configuration-test.nix \\ -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/nixos-19.09.tar.gz This will build all modules imported in configuration-test.nix and create a virtual machine containing the system, including sharry. After that completes, the system configuration can be found behind the ./result/system symlink. So it is possible to look at the generated systemd config for example: cat result/system/etc/systemd/system/sharry.service And with some more commands (there probably is an easier way…) the config file can be checked: cat result/system/etc/systemd/system/sharry.service | \\ grep ExecStart | \\ cut -d'=' -f2 | \\ xargs cat | \\ tail -n1 | \\ awk '{print $NF}'| \\ sed 's/.$//' | \\ xargs cat | jq To see the module in action, the vm can be started (the first line sets more memory for the vm): export QEMU_OPTS=\"-m 2048\" ./result/bin/run-sharrytest-vm"
    } ,    
    {
      "title": "Fail2ban",
      "url": "/sharry/doc/fail2ban",
      "content": "{{ page.title }} This contains examples for how to use sharry with fail2ban. fail2ban is a tool to detect brute force authentication attempts and ban offenders from any further attempts. It continuously reads the logs for lines that fit a regex and parses the ip address of the offender from the line. Fail2ban requires a jail and filter to be defined. The filter will define which log lines are considered lines detailing failed authentication attempts and where the ip address may be parsed. The jail will define which iptables chain and names should be used to ban the offending ip address in and which ports the offender will be banned for. It also defines how many authentication attempts an ip may try before it is considered an offender, how long the offender is banned for and the (time) window of log lines is considered while searching for offenders. An example jail config: [sharry] enabled = true port = 0:65535 filter = sharry action = iptables-allports[actname=name=sharry-in, name=sharry-in, chain=INPUT] iptables-allports[actname=sharry-fw, name=sharry-fw, chain=FORWARD] logpath = /path/to/your/sharry-logging-file maxretry = 3 bantime = 10m findtime = 1h An example filter config: [Definition] failregex = Authentication attempt failure for username .* from ip &lt;ADDR&gt; Password challenge failure for share id .* from ip &lt;ADDR&gt; No share with id .* Attempt by ip &lt;ADDR&gt; ignoreregex ="
    } ,    
    {
      "title": "Documentation",
      "url": "/sharry/doc/",
      "content": "Sharry Sharry allows to share files with others in a simple way. It is a self-hosted web application. The basic concept is: upload files and get a url back that can then be shared. How it works Authenticated users → others Authenticated users can upload their files on a web site together with an optional password and a time period. The time period defines how long the file is available for download. Then a public URL is generated that can be shared, e.g. via email, with everyone. While the download page is hard to guess, everyone who knows it can access the files. Others → Authenticated users Anonymous can send files to registered users. Each registered user can maintain alias pages. An alias page is also behind a “hard-to-guess” URL (just like the download page) and allows everyone to upload files to the corresponding user. The user belonging to the alias can be notified via email. Features Both ways: Receive and send files to/from anonymous users. Integration: Sharry aims to be easy to integrate in other environments. Authentication: There are many ways to authenticate users from different sources and/or use internal user management. REST Api exposing all the features, making it available for scripts. Reliable up- and downloads Uploads: While the server accepts standard multipart requests, it also supports the tus protocol allowing for resumable uploads. In case network goes down in the middle of uploading a large file, simply upload the same file again and it will start where it left off. Downloads: Using ETag and range requests allows the clients (the browser, mostly) to cache files and to download only portions of files. This makes it possible to efficiently view videos in the browser (being able to click into the timeline). Web client for managing and accessing shares. Signup Let all users create new accounts, only invited ones or none. Restrict public download pages using three properties: a lifetime, a password (acting as a second secret) and download-limit. Periodic cleanup will remove expired shares Send E-Mails from within Sharry (if configured) DBMS Data is stored in a relational database, supporting PostgreSQL, MariaDB and H2 (not using a separate database server). License This project is distributed under the GPLv3+"
    } ,      
    {
      "title": "Installation",
      "url": "/sharry/doc/install",
      "content": "{{ page.title }} This page contains detailed installation instructions. For a quick start, refer to this page. Sharry is a REST Server that also provides the web application. The web application runs in the browser and talks to the server using the REST Api. The download page provides pre-compiled packages and the development page contains build instructions. Prerequisites Java Very often, Java is already installed. You can check this by opening a terminal and typing java -version. Otherwise install Java using your package manager or see this site for other options. It is enough to install the JRE. The JDK is required, if you want to build sharry from source. Sharry has been tested with Java version 1.8 (or sometimes referred to as JRE 8 and JDK 8, respectively). The pre-build packages are also build using JDK 8. But a later version of Java should work as well. Database Sharry stores all its information (files, accounts etc) in a database. The following products are supported: PostreSQL MariaDB H2 The H2 database is an interesting option for personal and mid-size setups, as it requires no additional work (i.e. no separate db server). It is integrated into sharry and works really well. It is also configured as the default database. For large installations, PostgreSQL or MariaDB is recommended. Create a database and a user with enough privileges (read, write, create table) to that database. When using H2, make sure to add the options ;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE at the end of the url. See the default config for an example. Installing from ZIP files After extracting the zip files, you’ll find a start script in the bin/ folder. Installing from DEB packages The DEB packages can be installed on Debian, or Debian based Distros: $ sudo dpkg -i sharry*.deb Then the start scripts are in your $PATH. Run sharry-restserver from a terminal window. The packages come with a systemd unit file that will be installed to autostart the services. Running Run the start script (in the corresponding bin/ directory when using the zip files): $ ./sharry-restserver*/bin/sharry-restserver This will startup using the default configuration. The configuration should be adopted to your needs. For example, the database connection is configured to use a H2 database that is created in the /tmp directory. Please refer to the configuration page for how to create a custom config file. Once you have your config file, simply pass it as argument to the command: $ ./sharry-restserver*/bin/sharry-restserver /path/to/server-config.conf After starting the rest server, you can reach the web application at path /app, so using default values it would be http://localhost:9090/app. The root path, http://localhost:9090/, redirects to this url. You should be able to create a new account and sign in. Options The start scripts support some options to configure the JVM. One often used setting is the maximum heap size of the JVM. By default, java determines it based on properties of the current machine. You can specify it by given java startup options to the command: $ ./sharry-restserver*/bin/sharry-restserver -J-Xmx1G -- /path/to/server-config.conf This would limit the maximum heap to 1GB. The double slash separates internal options and the arguments to the program. Another frequently used option is to change the default temp directory. Usually it is /tmp, but it may be desired to have a dedicated temp directory, which can be configured: $ ./sharry-restserver*/bin/sharry-restserver -J-Xmx1G -Djava.io.tmpdir=/path/to/othertemp -- /path/to/server-config.conf The command: $ ./sharry-restserver*/bin/sharry-restserver -h gives an overview of supported options. System properties All options that are given with -D are called system properties. These can be used to overwrite certain configuration values. System properties always take precedence over values defined in config files. This can be handy to temporarily change some configuration, for example, enable the fixed admin account like this: $ ./sharry-restserver*/bin/sharry-restserver -Dsharry.restserver.backend.auth.fixed.enabled=true -- /path/to/server-config.conf"
    } ,      
    {
      "title": "Migration",
      "url": "/sharry/doc/migration",
      "content": "{{ page.title }} For users of Sharry version 0.6.x, the database schema must be migrated (kind of) manually. The application doesn’t do it automatically. However, there is a built-in script that converts the old schema into the new one. But: At first, please backup the data. If you don’t care, then its probably easier to just start with a new database :). When migrating from Sharry version &lt; 0.6.x, you’ll need first to run a 0.6 version against the database. This will evolve the db schema to the point where the migration-script from 1.0 can take it further. Then follow this guide. Postgres and MariaDB For these databases, you can start the restserver binary with a special option -Dsharry.migrate-old-dbschema=true. ./sharry-restserver-1.9.0/bin/sharry-restserver -Dsharry.migrate-old-dbschema=true ./sharry-new.conf This will not start the restserver but rather run the migration against the database configured in given config file. If that completes successfully, you can startup sharry as normal (without that option). H2 H2 is a little more involved. This is because the database initialization changed and the parameters given with the URL cannot be changed afterwards. The steps are roughly this: create a dump change the dump to make it postgres compatible import it into a new database (using the new connection settings) run the migration from above Dump The dump can be created using a tool provided by h2: Script (doc). It is in the jar file that is on your disk if you have sharry installed. So the dump can be created like this: java -cp sharry-restserver-1.9.0/lib/com.h2database.h2-1.4.200.jar org.h2.tools.Script -url \"jdbc:h2:///var/data/sharry/sharry-old-db\" -user sa -password \"\" This will create a backup.sql file in the current directory. Change the Dump This dump uses some incompatible things: all identifiers are upper case and the datatype for a blob is called bytea in postgres. This can be changed with GNU Sed: sed -i 's,\"CHUNKDATA\" BLOB NOT NULL,\"CHUNKDATA\" BYTEA NOT NULL,g' backup.sql sed -i 's,\"[_A-Z]*\",\\L&amp;,g' backup.sql The first command fixes the datatype thing and the second converts all words in quotes into lowercase. Note: for the second command, the GNU version of Sed is required. Import the Dump Now the changed dump must be imported into a new database. Since h2 creates one on demand, just run the command and specify now the new connection – to an unexisting file and with the required settings MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE. Again, a tool from h2 can be used (RunScript, doc): java -cp sharry-restserver-1.9.0/lib/com.h2database.h2-1.4.200.jar org.h2.tools.RunScript -url \"jdbc:h2:///var/data/sharry/sharry-newdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" -user sa -password \"\" Migrate Now run sharry with the migration setting as described above for Postgres and MariaDB."
    } ,    
    {
      "title": "Nix/NixOS",
      "url": "/sharry/doc/nix",
      "content": "{{ page.title }} Install via Nix Sharry can be installed via the nix package manager, which is available for Linux and OSX. Sharry is currently not part of the nixpkgs collection, but you can use the derivation from this repository. This is sometimes referred to as import from derivation. For example, the builtins.fetchTarball function can be used to retrieve the files; then import the release.nix file: let sharrysrc = builtins.fetchTarball \"https://github.com/eikek/sharry/archive/master.tar.gz\"; in import \"${sharrysrc}/nix/release.nix\"; This creates a set containing a function for creating a derivation for sharry. This then needs to be called like other custom packages. For example, in your ~/.nixpkgs/config.nix you could write this: let sharrysrc = builtins.fetchTarball \"https://github.com/eikek/sharry/archive/master.tar.gz\"; sharry = import \"${sharrysrc}/nix/release.nix\"; in { packageOverrides = pkgs: let callPackage = pkgs.lib.callPackageWith(custom // pkgs); custom = { sharry = callPackage sharry.currentPkg {}; }; in custom; } Then you can install sharry via nix-shell or nix-env, for example: $ nix-env -iA nixpkgs.sharry You may need to replace nixpkgs with nixos when you’re on NixOS. The expression sharry.currentPkg refers to the most current release of Sharry. So even if you use the tarball of the current master branch, the release.nix file only contains derivations for releases. The expression sharry.currentPkg is a shortcut for selecting the most current release. For example it translates to sharry.pkg sharry.cfg.v1_9_0 – if the current version is 1.9.0. Sharry as a service on NixOS If you are running NixOS, there is a module definition for installing Sharry as a service using systemd. You need to import the release.nix file as described above in your configuration.nix and then append the sharry module to your list of modules. Here is an example: { config, pkgs, ... }: let sharrysrc = builtins.fetchTarball \"https://github.com/eikek/sharry/archive/master.tar.gz\"; sharry = import \"${sharrysrc}/nix/release.nix\"; in { imports = [ mymodule1 mymodule2 ] ++ sharry.modules; nixpkgs = { config = { packageOverrides = pkgs: let callPackage = pkgs.lib.callPackageWith(custom // pkgs); custom = { sharry = callPackage sharry.currentPkg {}; }; in custom; }; }; services.sharry = { enable = true; base-url = \"http://sharrytest:7878\"; backend = { auth = { oauth = []; }; }; }; ... } Please see the nix/module.nix file for the set of options. The nixos options are modelled after the default configuration file."
    } ,    
    {
      "title": "Quickstart",
      "url": "/sharry/doc/quickstart",
      "content": "Quickstart To quickly try out sharry, follow these steps: Download a zip (version 1.9.0) from the release page. e.g. sharry-restserver-1.9.0.zip Unpack it to some place. $ unzip sharry-restserver-1.9.0.zip Run the executable: $ /path/to/extracted-zip/bin/sharry-restserver Goto http://localhost:9090/, signup and login If you want to know more, for example what can be configured, checkout these pages. Quickstart with Docker There is a docker-compose setup available in the /docker folder. Clone the github repository $ git clone https://github.com/eikek/sharry Change into the docker directory: $ cd sharry/docker Run docker-compose up: $ docker-compose up Goto http://localhost:9090/, signup and login The directory contains a file sharry.conf that you can modify as needed."
    } ,    
    {
      "title": "Rest Api",
      "url": "/sharry/doc/rest",
      "content": "REST Api Sharry is provided as a REST server and a web application client. The REST Api is specified using openapi 3.0 and it’s static documentation can be seen here. The “raw” openapi.yml specification file can be found here. The calls are divided into 4 categories: /open/*: no authentication is required to access /sec/*: an authenticated user is required /alias/*: these routes are allowed with a valid alias id given as header Sharry-Alias /admin/*: an authenticated user that is admin is required Authentication works by logging in with username/password (or an oauth2 flow) that generates a token that has to be sent with every request to a secured and admin route. It is possible to sent it via a Cookie header or the special Sharry-Auth header. Files can be uploaded using different methods. There is an endpoint that can take all files and meta data from one single request. For more reliable uploads, the server implements the tus protocol that allows to resume failed or paused uploads. Authentication The unprotected route /open/auth/login can be used to login with account name and password. The response contains a token that can be used for accessing protected routes. The token is only valid for a restricted time which can be configured (default is 5 minutes). New tokens can be generated using an existing valid token and the protected route /sec/auth/session. This will return the same response as above, giving a new token. This token can be added to requests in two ways: as a cookie header or a “normal” http header. If a cookie header is used, the cookie name must be sharry_auth and a custom header must be named Sharry-Auth. Live Api Besides the statically generated documentation at this site, the rest server provides a openapi generated documenation, that allows playing around with the api. It requires a running sharry rest server. If it is deployed at http://localhost:9090, then check this url: http://localhost:909/api/doc Examples Login with username/password $ curl -d'{\"account\":\"eike\", \"password\":\"test\"}' http://localhost:9090/api/v2/open/auth/login Output: {\"id\":\"6ExuF2eYpvd-hFPyEk4jAdy-aGiyyyDRk3q-nHkAE6kjViU\",\"user\":\"eike\",\"admin\":false,\"success\":true,\"message\":\"Login successful\",\"token\":\"1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=\",\"validMs\":300000} The token must be used with subsequent requests. It is valid for 5 minutes. Get a new token $ curl -XPOST -H 'Sharry-Auth: 1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=' http://localhost:9090/api/v2/sec/auth/session Output: {\"id\":\"6ExuF2eYpvd-hFPyEk4jAdy-aGiyyyDRk3q-nHkAE6kjViU\",\"user\":\"eike\",\"admin\":false,\"success\":true,\"message\":\"Login successful\",\"token\":\"1577122497189-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$9/VNIq8e3YxHKTLyE0JwbO-bI0CpZnEsmfhDHxsjwhe7qzQaSY=\",\"validMs\":300000} Get your shares $ curl -XGET -H 'Sharry-Auth: 1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=' http://localhost:9090/api/v2/sec/share/search Output: {\"items\":[{\"id\":\"7wNPzKepw4g-gKgSfQ376tJ-HSifxLc33r5-xY8FigeF7wG\",\"name\":null,\"aliasName\":null,\"validity\":172800000,\"maxViews\":30,\"password\":false,\"created\":1577102005295,\"files\": 1,\"size\":199640,\"published\":null},{\"id\":\"44EPQPe7Lo2-KnUCp3kiQNg-dJ4oxiAQ5Lh-etMiDwe5KD3\",\"name\":null,\"aliasName\":null,\"validity\":172800000,\"maxViews\":30,\"password\":false,\"created \":1577101969643,\"files\":1,\"size\":192886,\"published\":null}]} Create an alias page $ curl -XPOST -H 'Sharry-Auth: 1577122785983-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$kceo1M6cRNpMpptb0F67uO-sZurk/s03VHuzpxLGhT+AUF4TjU=' -d'{\"name\":\"test alias\",\"validity\": 172800000, \"enabled\":true,\"members\":[]}' http://localhost:9090/api/v2/sec/alias Output: {\"success\":true,\"message\":\"Alias successfully created.\",\"id\":\"HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV\"} Upload a file to the new alias page Using the id, upload files via multipart/form-data requests. You can upload multiple files at once. $ curl -XPOST -F file=@P1020416.JPG -F file=@P1020422.JPG -H 'Sharry-Alias: HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV' http://localhost:9090/api/v2/alias/upload Output: {\"success\":true,\"message\":\"Share created.\",\"id\":\"8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8\"} Get Details about the share This requires authenticated users, of course. The | jq pipes the one-line json output through a program that formats it. $ curl -H'Sharry-Auth: 1577132299230-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$jFhOEGYktHb8yiLF5mhHjO-CvDL2MniUH+RQv8dTSWPwhSUeIw=' http://localhost:9090/api/v2/sec/share/8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8 | jq Output: { \"id\": \"8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8\", \"name\": null, \"aliasId\": \"HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV\", \"aliasName\": \"test alias\", \"validity\": 172800000, \"maxViews\": 30, \"password\": false, \"descriptionRaw\": null, \"description\": null, \"created\": 1577132473544, \"publishInfo\": null, \"files\": [ { \"id\": \"6QcXQ9qeSQb-VYF2p9M23XT-bMPRFkmtsPK-ejjJUns3Ymk\", \"filename\": \"P1020416.JPG\", \"size\": 2829079, \"mimetype\": \"image/jpeg\", \"checksum\": \"8ffe8da9d49b7e6590b78362ed0acd4156f4bccaa724c710560a57bd3c54d74d\", \"storedSize\": 2829079 }, { \"id\": \"Eur8FJj4uxL-q9NYVBqYi1L-jnsEFKPwCYQ-6Z81iazysjD\", \"filename\": \"P1020422.JPG\", \"size\": 3692609, \"mimetype\": \"image/jpeg\", \"checksum\": \"424bcfa141f61a73269466102ee1a826f1fae31a847a5861500fc4cbdfb1732f\", \"storedSize\": 3692609 } ] } The output contains the two files that have been uploaded. Also interesting is the storedSize property. This indicates how many bytes really reached the server. The size property uses the value as advertised by the uploader. If storedSize does not equal size then the file is not fully uploaded."
    } ,    
    {
      "title": "Reverse Proxy",
      "url": "/sharry/doc/reverseproxy",
      "content": "{{ page.title }} This contains examples for how to use sharry behind a reverse proxy. For the examples below, assume the following: Sharry app is available at 192.168.1.11:9090. The external domain/hostname is sharry.example.com Configuring Sharry These settings require a complement config part in the sharry configuration file: First, if Sharry REST server is on a different machine, you need to change the bind.address setting to be either 0.0.0.0 or the ip address of the network interface that the reverse proxy server connects to. sharry.restserver { # Where the server binds to. bind { address = \"192.168.1.11\" port = 9090 } } Note that a value of 0.0.0.0 instead of 192.168.1.11 will bind the server to every network interface. If it is running on the same machine as the reverse proxy server, you can set localhost instead. Sharry needs to know the external url. The base-url can be used to explicitely specify this url. If it is left at its default value, sharry finds the external url from the request. It is recommended to set this url, if you have a single external url. Using above values, it must be set to https://sharry.example.com. sharry.restserver { # This is the base URL this application is deployed to. This is used # to create absolute URLs and to configure the cookie. # # Note: Currently deploying behind a path is not supported. The URL # should not end in a slash. base-url = \"https://sharry.example.com\" ... } The maximum request size should probably be increased at the reverse proxy. This depends on your machine, of course. The sharry related setting is sharry.restserver.webapp.chunk-size. This defines the size that is used for uploading chunks of data in one request. sharry.restserver { webapp { # Chunk size used for one request. The server will re-chunk the # stream into smaller chunks. But the client can transfer more in # one requests, resulting in faster uploads. # # You might need to adjust this value depending on your setup. A # higher value usually means faster uploads. chunk-size = \"100M\" } Here a chunk-size of 100M is used and the reverse proxy must be set to at least this value. Below it is set to 105M, just to be sure. If you have examples for more servers, please let me know or add it to this site. Nginx This defines two servers: one listens for http traffic and redirects to the https variant. Additionally it defines the let’s encrypt .well-known folder name. For more information about how to setup let’s encrypt, please refer to their documentation and/or the nginx documentation. The https server endpoint is configured with the let’s encrypt certificates and acts as a proxy for the application at 192.168.1.11:9090. The setting client_max_body_size is relevant, too. This is the maximum size of a single requests. This must be greater than sharry’s webapp.chunk-size setting. The setting proxy_buffering off; disables buffering responses from the application coming to nginx. Buffering may introduce backpressure problems if the client is not reading fast enough. The response coming from the application may quickly be too large to fit in memory and nginx then writes a temporary file (which is limited to 1G by default). If this limit is reached, nginx waits until the client has received all disk buffered data which in turn can result in send timeouts. http { map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 0.0.0.0:80 ; listen [::]:80 ; server_name subdomain.otherdomain.tld ; location /.well-known/acme-challenge { root /var/data/nginx/ACME-PUBLIC; auth_basic off; } location / { return 301 https://$host$request_uri; } } server { listen 0.0.0.0:443 ssl http2 ; listen [::]:443 ssl http2 ; server_name sharry.example.com ; location /.well-known/acme-challenge { root /var/data/nginx/ACME-PUBLIC; auth_basic off; } ssl_certificate /var/lib/acme/sharry.example.com/fullchain.pem; ssl_certificate_key /var/lib/acme/sharry.example.com/key.pem; ssl_trusted_certificate /var/lib/acme/sharry.example.com/full.pem; location / { proxy_pass http://192.168.1.11:9090; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; } } } Serving two domains This config shows an example to serve nginx on two domains, while the sharry app is fixed to one domain. This will allow to always use the same base-url in e-mail templates, while serving the webapp on different domains. This is in contrast to the default behaviour (leaving base-url setting to its default): the url in mail templates would change according to the request. # sharry.conf: base-url = \"https://example.org\" map $http_upgrade $connection_upgrade { default upgrade; '' close; } # this is the domain as configured in sharry, serve as is server { listen [::]:443 ssl default_server; server_name example.org; root /srv/http; location / { # This is the nginx example from the sharry docs proxy_pass http://localhost:9090/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; } } # this is the second domain as configured in sharry, do the replacing server { listen [::]:80 default_server; server_name example.com; root /srv/http; location / { # This is the nginx example from the sharry docs proxy_pass http://localhost:9090/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; # Replace the protocol/domain in Location headers proxy_redirect https://example.org/ http://example.com/; # Replace the protocol/domain in the content sub_filter_once off; sub_filter \"https://example.org\" \"http://example.com\"; sub_filter \"example.org\" \"example.com\"; # sub_filter does not work with gzip, so enforce plaintext # see https://www.nginx.com/resources/wiki/modules/substitutions/#subs-filter-types proxy_set_header Accept-Encoding \"\"; } }"
    } ,    
    {
      "title": "Screenhots",
      "url": "/sharry/doc/screenshots",
      "content": "Screenshots These are some screenshots to get a little impression of the web client. It might be outdated, though. Home Screen Uploading a file View Share Details View Link to public page View Files View Files with preview Preview a single file Mobile View"
    } ,      
    {
      "title": "ShareX",
      "url": "/sharry/doc/sharex",
      "content": "{{ page.title }} ShareX is a popular screenshot tool. Below is a “custom upload” template to allow uploading screenshots to Sharry from ShareX. { \"Version\": \"1.3.1\", \"DestinationType\": \"ImageUploader, TextUploader, FileUploader\", \"RequestMethod\": \"POST\", \"RequestURL\": \"https://your.sharry/api/v2/alias/upload\", \"Body\": \"MultipartFormData\", \"Headers\": { \"Sharry-Alias\": \"some-alias-id\" }, \"FileFormName\": \"file[]\", \"URL\": \"https://your.sharry/app/upload/$json:id$\" } You need to replace http://your.sharry with your sharry url and specify some alias id, replacing some-alias-id in the example. The alias id can be found at any alias page that you have access to."
    } ,    
    {
      "title": "Webapplication",
      "url": "/sharry/doc/webapp",
      "content": "Webapplication The web client is written in Elm, an awesome programming language for the web :-). The tus javascript client library is used to realize the resumable uploads. All the css is provided by TailwindCSS. Creating a new share After logging in, you can create new shares: The details are all optional and can also be changed afterwards. It is required to specfiy a description, some files or both. Otherwise submitting won’t work. The detail options are explained below. Name A share may have a name. This name is mainly meant for the owner to helps finding shares easier in the list view. The name will also be used as the head line, if the description doesn’t contain a markdown headline (a line starting with #). In that case, users who access the published site, will see it. Description You can add some text to a share which will be displayed at the download page. The description can be markdown and is converted to HTML when being displayed. Furthermore, the description text is processed as a mustache template and allows to refer to the attached files. You can access the following properties of any uploaded file: id filename url mimetype size length checksum The size is the file size as a human readable string, while length is the number in bytes. You can refer to files using their name or index in the list. When using the file name, all dots in there must be removed. {% raw %} {{#file.0}}{{url}}{{/file.0}} {% endraw %} or {% raw %} {{filename.dsc0100JPG.url}} {% endraw %} This makes it possible to embed files in the description, for example to display an image file, you could write the following description: {% raw %} ![an image]({{filename.DSCF0343JPG.url}}) {% endraw %} There is also a files property that can be used to iterate through all uploaded files. So this would render the id and url of all files: {% raw %} {{#files}} - {{id}}: {{url}} {{/files}} {% endraw %} Validity Time Every upload has a validity time after which the uploaded files are “expired”. Then the public download page is not visible anymore and the files can’t be downloaded from non-protected urls. The files are there and the user that owns them still has access. They are eventually removed by a cleanup job. Password The files can be further protected by a password. The download page requires this password in order to download the files. The idea is that this password is a second secret, next to the url. You can share the URL using one channel (maybe e-mail) and the password using another channel. A person must have both things in order to see the files. Maximum Views This setting restricts the number of accesses to the download page. If the download page is accessed more than this number, it will not work anymore. Publish / Unpublish / Republish A share that has not been published can only be accessed by its owner. In order to create a link for everyone else, click the Publish button in the top right of the detail view of a share. Once a share is published that circle is green. The expiry time is calculated from the validity time added to the point in time the share is publshed. You’ll see it in the details pane. If the share is published you can get the link clicking on the Share Link pane. You can copy&amp;paste it, scan the QR code or send it via e-Mail (if sharry is configured for that, it can be sent directly in the webapp). You can unpublish a share at any time. The public link will immediately stop working and the circle will be empty. Then there are two options for publishing it again: one will generate a new random link, the other option reuses the current public link. If you hit the Publish button in the top right corner again, the share will be published anew – meaning the current validity time is added to the current point in time, but the public link will not change. All people that you have shared it with earlier can immediately open the site again. If you rather like to publish it to a new URL, click the black publish button at the bottom of the Detail pane (see the screenshot below). Edit Details The share properties can be changed in the detail view of a share. The detail view consists of a top menu, then follows the description, then the file list menu and finally the list of files. Open the Detail tab in the top menu to see all properties. Properties that have the little blue edit icon in front of their names can be changed by clicking that icon. The description can be edited by clicking the edit icon next to the Publish button in the top right corner. It is also possible to add or remove files of that share. Click the right menu item of the file list menu and the upload form appears. Alias Pages The alias page is a way to let other users upload files for you. The idea is the same as with shared downloads: there is a cryptic URL you can share with others. This url allows to upload files that will be associated to the owner of that alias page. Click in the top right menu that opens a drop down menu and choose Aliases. There you can create, edit and remove alias pages. Alias pages are also convenient for quickly uploading files for yourself, as they don’t require any authentication. For example, using curl you could do: $ curl -H'Sharry-Alias: E5EohHtJHxN' -F file=@test.jpg -F file=@logo.jpg http://localhost:9090/api/v2/alias/upload {\"success\":true,\"message\":\"Share created.\",\"id\":\"FDQvHK2LVGe-SjkDjQxMiSo-8fPyBqKX3AY-nmWWnDsrRX3\"} See the REST page for more details on the various routes. Alias Members An alias can specify a list of users that are then members of that alias. This allows to give access to all uploads through this alias to the members. Every member can edit/delete/publish etc the shares that are created via the corresponding alias. While all members can see the alias and manage corresponding uploads, editing its properties is only possible by its creator. This may be useful to give a group of people access to the same files and to make it simpler to share files among registered users."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
