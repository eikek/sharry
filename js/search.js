// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Configuring",
      "url": "/sharry/doc/configure",
      "content": "Configuring Sharry’s executable can take one argument – a configuration file. If that is not given, the defaults are used. The config file overrides default values, so only values that differ from the defaults are necessary to specify. Environment variables can be used as well to override values from the config file. Variable names always start with SHARRY_ and the remainder can be derived from the corresponding config option by replacing period . and dash - by an underscore _, but excluding the root namespace sharry.restserver. For example, the config option sharry.restserver.bind.address would be SHARRY_BIND_ADDRESS as environment variable. A value given as environment variable has priority. File Format The format of the configuration files can be HOCON, JSON or whatever the used config library understands. The default values below are in HOCON format, which is recommended, since it allows comments and has some advanced features. Please refer to their documentation for more on this. The hocon format allows to include environment variables, allowing to mix and match both variants if desired. For example: … mode = \"open\" mode = ${?SHARRY_BACKEND_SIGNUP_MODE} … would use the value \"open\" if the environment varible SHARRY_BACKEND_SIGNUP_MODE is not defined, because it would overwrite the previously defined value. Important Config Options The configuration for the REST server is below sharry.restserver. JDBC This configures the connection to the database. By default, a H2 database in the current /tmp directory is configured. This will create the database on demand in this directory. The config looks like this: sharry.restserver.backend.jdbc { url = ... user = ... password = ... } The url is the connection to the database. It must start with jdbc, followed by name of the database. The rest is specific to the database used: it is either a path to a file for H2 or a host/database url for MariaDB and PostgreSQL. When using H2, the user is sa, the password can be empty and the url must include these options: ;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE Examples PostgreSQL: url = \"jdbc:postgresql://localhost:5432/sharrydb\" MariaDB: url = \"jdbc:mariadb://localhost:3306/sharrydb\" H2 url = \"jdbc:h2:///path/to/a/file.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" Database Checks The setting database-domain-checks is used when inspecting errors that happen when uploading files. It allows to translate database error messages into a message that is presented to the end user. Please see this issue for more information and motivation. The example provided is this: sharry.restserver.backend.share { # Allows additional database checks to be translated into some # meaningful message to the user. # # This config is used when inspecting database error messages. # If the error message from the database contains the defined # `native` part, then the server returns a 422 with the error # messages given here as `message`. # # See issue https://github.com/eikek/sharry/issues/255 – the # example is a virus check via a postgresql extension \"snakeoil\". database-domain-checks = { # Example: This message originates from postgres with an # enabled snakeoil extension. This extension allows to virus # check byte arrays. It must be setup such that the `bytea` # type of the filechunk table is changed to the type # `safe_bytea`: # # CREATE EXTENSION pg_snakeoil; # CREATE DOMAIN public.safe_bytea as bytea CHECK (not so_is_infected(value)); # ALTER TABLE public.filechunk ALTER COLUMN chunkdata TYPE safe_bytea; snakeoil = { enabled = false native = \"domain safe_bytea violates check constraint\" message = \"The uploaded file contains a virus!\" } } } Example for Snakeoil The extension snakeoil for PostgreSQL allows to check uploaded binary data for viruses. In order to use this, you need to change the data type for the binary files. This must be applied after sharry has started at least once to initialize its database! The following steps must be done manually: install pg_snakeoil - e.g. on ubuntu systems package: postgresql-12-snakeoil execute the following sql commands on the sharry postgres database: CREATE EXTENSION pg_snakeoil; CREATE DOMAIN public.safe_bytea as bytea check (not so_is_infected(value)); ALTER TABLE public.filechunk ALTER COLUMN chunkdata TYPE safe_bytea; Then add the above setting into your config file. Test files can be found here. Files By default, the files are also stored in the configured database. This works quite well, but you can also choose to store the files somewhere else: either in the local filesystem or in an S3 compatible object storage. This is configured in the files section: # How files are stored. files { # The id of an enabled store from the `stores` array that should # be used. default-store = \"database\" # A list of possible file stores. Each entry must have a unique # id. The `type` is one of: default-database, filesystem, s3. # # All stores with enabled=false are # removed from the list. The `default-store` must be enabled. stores = { database = { enabled = true type = \"default-database\" } filesystem = { enabled = false type = \"file-system\" directory = \"/some/directory\" # If true, empty directories that can be left behind after deleting # a file are removed as well. clean-empty-dirs = true } minio = { enabled = false type = \"s3\" endpoint = \"http://localhost:9000\" access-key = \"username\" secret-key = \"password\" bucket = \"sharry\" } } ... } This config section requires to define a file store in stores and then reference the key in default-store. Within stores you can define what kind of storage to use via the type attribute. This can be one of: s3, file-system or default-database. Depending on type more information is required. For example, the filesystem needs the base directory to use, or the above example for Minio requires credentials and a bucket. Changing file stores The last part in the files section looks like this: # Allows to copy files from one store to the other *before* sharry # will be available. It is recommended to set the `enabled` flag to # false afterwards and restart sharry. # # Files are only copied, they are *not* removed from the source # store. copy-files = { enable = false # A key in the `backend.files` config identifying the store to # copy from. source = \"database\" # A key in the `backend.files` config identifying the store to # copy the files to. target = \"minio\" # How many files to copy in parallel. parallel = 2 } This allows you to have Sharry copy all files from one store to the other on startup. So to change from database to minio as in the example, set enabled to true and change the default-store to minio (the target store). When starting up sharry it will first copy all files to the minio store before it is available. Bind The host and port the http server binds to. sharry.restserver.bind { address = localhost port = 9090 } By default, it binds to localhost and some predefined port. Base-url The base url is an important setting that defines the URL where sharry can be reached (the external url). The REST server uses it to create absolute urls and to configure the authenication cookie. These URLs are sent to the client, so they must resolve back to the sharry server. If you see “network error” error messages in the browser, then this setting is probably not correct. By default it is set to http://localhost:9090. If you leave it at localhost, then sharry uses the request to obtain the real external url dynamically by inspecting http headers and finally falling back to the bind.address|port. However, if you have a single external url, it is recommended to set this here. Examples sharry.restserver.base-url = \"https://sharry.example.com\" Registration Options This defines if and how new users can create accounts. There are 3 options: closed no new user can sign up open new users can sign up invite new users can sign up but require an invitation key sharry.restserver.backend.signup { mode = \"open\" # If mode == 'invite', a password must be provided to generate # invitation keys. It must not be empty. invite-password = \"\" # If mode == 'invite', this is the period an invitation token is # considered valid. invite-time = \"3 days\" } The mode invite is intended to open the application only to some users. An admin user can create invitation keys and distribute them to the desired people. While the user must be admin, it is also necessary to provide the invite-password. The idea is that only the person who installs sharry knows this. If it is not set (must be non-empty), then invitation won’t work. New invitation keys can be generated from within the web application or via REST calls (using curl, for example). curl -X POST -H 'Sharry-Auth: ' -d '{\"password\":\"blabla\"}' \"http://localhost:7880/api/v1/open/signup/newinvite\" Authentication The initial authentication will generate an authentication token which is valid for some time. Subsequent calls to secured routes can use this token. The token can be given as a normal http header or via a cookie header. The following options configure this token: sharry.restserver.backend.auth { server-secret = \"hex:caffee\" # or \"b64:Y2FmZmVlCg==\" session-valid = \"8 minutes\" } The server-secret is used to sign the token. If multiple REST servers are deployed, all must share the same server secret. Otherwise tokens from one instance are not valid on another instance. The secret can be given as Base64 encoded string or in hex form. Use the prefix hex: and b64:, respectively. If these prefixes are missing, the string’s utf8 bytes are used. The session-valid deterimens how long a token is valid. This can be just some minutes, the web application obtains new ones periodically. So a rather short time is recommended. The interval the webapp retrieves a new token can be configured, too. It must be at least 30s below the session-valid time. sharry.restserver.webapp { auth-renewal = \"4 minutes\" } Login Modules Login modules are used to initially authenticate a user given some credentials. There are some modules that take a username/password pair and hand it to an external service or program for verification. If valid, sharry creates an account transparently. Then there is the oauth setting which supports authentication via OAuth using “OAuth Code Flow”. All login modules can be enabled/disabled and have an order property that defines the order the login modules are tried. The modules are tried in the specified order until one gives a response. Fixed This is a simple login module for bootstrapping. It defines an admin account using the supplied username and password (plain text) from the config file. fixed { enabled = false user = \"admin\" password = \"admin\" order = 10 } It is disabled by default. If the given username doesn’t match the configured username this login module is skipped and the next is tried. Http The http login module issues a http request with the username/password pair as payload. The response status code determines valid authentication. http { enabled = false url = \"http://localhost:1234/auth?user={{user}}&amp;password={{pass}}\" method = \"POST\" body = \"\" content-type = \"\" order = 20 } If the method is POST, the body is sent as specified using the given content type. The body and url are processed before as mustache templates, where {{user}} and {{pass}} are replaced by their actual values. For other requests than POST, the body is ignored. Http Basic The http-basic login module issues a http request with an Authorization header against some configured url. The header uses the Basic scheme to transport the username/password pair. http-basic { enabled = false url = \"http://somehost:2345/path\" method = \"GET\" order = 30 } If the response is successful (in 2xx), the user is authenticated. Command Allows to validate a username/password pair using some external system command. This is the most flexible approach. command { enabled = false program = [ \"/path/to/someprogram\" \"{{login}}\" \"{{pass}}\" ] # the return code to consider successful verification success = 0 order = 30 } The return code of the command is used to determine valid authentication. The program value is an array where the first item is the path to the program and subsequent elements define its arguments. All arguments are processed as a mustache template and variables {{user}} and {{pass}} are replaced by their actual values. Internal The internal login module simply authenticates against the sharry database. If it is disabled, you should disable signup, too, because those user won’t be authenticated. Proxy The proxy option allows automatically authenticate users by trusting specific request headers. The configured headers of the login request to open/auth/proxy are read and a user account is created if missing. Be aware that sharry blindly trusts these headers. proxy { enabled = false user-header = \"X-Valid-User\" email-header = \"X-User-Email\" } The webapp automatically logs the user in, if the auth configuration only consists of proxy auth and nothing else. OAuth There is now an option to authenticate using a external provider supporting the OAuth “code flow”. There are two examples in the config file for Github and Google. I tried to generalise it as much as possible, but (it seems to me) OAuth is not really a protocol, every provider may choose to do it little differently. The oauth login module can be configured with multiple such providers. Here is an example: oauth = { github = { enabled = false name = \"Github\" icon = \"fab fa-github\" authorize-url = \"https://github.com/login/oauth/authorize\" token-url = \"https://github.com/login/oauth/access_token\" user-url = \"https://api.github.com/user\" user-id-key = \"login\" scope = \"\" client-id = \"&lt;your client id&gt;\" client-secret = \"&lt;your client secret&gt;\" } } Each such entry in the oauth object results in a button on the login screen. The key (github in the above example) is used to refer to this provider as its id. Here is how it roughly works: If a user clicks this button, it reaches a specific url in sharry. Sharry will read the corresponding config entry and redirect to the provider adding all the necessary details. The user then authenticates at the provider, which redirects back to sharry – so this method only works if sharry is publicly available, obviously. Then sharry does one more request to turn the code from the redirect into a different code. And then it tries to get the account name. Let’s go through the config values of one entry: enabled: allows to disable this entry without removing it from the file. id: the id that is used in the url behind the button on the login screen. It is also used to amend the account name. name: The name rendered as button text. icon: an icon for the button, included are fa-github, fa-openid, fa-google, fa-user, fa-right-to-bracket authorize-url this is the URL of the provider where sharry redirects to at first, attaching client_id and the redirect uri back to sharry. token-url: The url to the provdier where the response from the authorize-url can be turned into a token. user-url: The url to the provider that retrieves the user information given a token as obtained from token-url. user-id-key: Now it get’s a bit hairy…. The protocol doesn’t define (afaik) a common way how to exchange user data. So google does it different from github. Sharry supports JSON responses only and uses the value of user-id-key to lookup a value in that response structure. For example, the github response is a simple JSON object, where the login name is at field login. The path must evaluate to a string. This value is used for the new account inside sharry. Another value that often works is preferred_username. user-email-key: optional, if present is used to populated the email field of the newly created account. scope: optional, can be empty. Allows to specify the open id scopes to use when initiating the authentication. This can be useful to return custom data from the IDP to be used with user-email-key or user-id-key client-id and client-secret These are provider specific values that you need to obtain there. With github, for example, you register a new “app” which generates these values. Once sharry gets the account name, it creates a new account (if it not exists already) using the account name from the provider amended with @&lt;id&gt;. I only tested this with github and google, I would appreciate any information on how it works with other providers. Cleanup Sharry has a periodic cleanup job that will delete ‘invalid’ resources. This cleanup job runs in the backend and is triggered by a timer every interval as defined in the cleanup block. It cleans up the following resources: Expired, published shares and their files are removed once the expiration datetime is older than invalid-age defined in the cleanup block. Expired invites are removed based on the invite-time from the signup block. Orphaned files are removed. However, orphaned files should not happen as long as all shares and files are maintained by only sharry and not any external modifications. Default Config sharry.restserver { # This is the base URL this application is deployed to. This is used # to create absolute URLs and to configure the cookie. # # Note: Currently deploying behind a path is not supported. The URL # should not end in a slash. base-url = \"http://localhost:9090\" # Maximum size when returning result lists. max-page-size = 100 # Where the server binds to. bind { address = \"localhost\" port = 9090 } file-download { # For open range requests, use this amount of data when # responding. download-chunk-size = \"4M\" } # Configures logging logging { # The format for the log messages. Can be one of: # Json, Logfmt, Fancy or Plain format = \"Fancy\" # The minimum level to log. From lowest to highest: # Trace, Debug, Info, Warn, Error minimum-level = \"Warn\" # Override the log level of specific loggers levels = { \"sharry\" = \"Info\" \"org.flywaydb\" = \"Info\" \"binny\" = \"Info\" \"org.http4s\" = \"Info\" } } # The alias-member feature allows to add users to an alias page to # automatically make all shares that were uploaded through the # corresponding alias available to all members. This allows to # search for other users via a http call. If this feature is # disabled, the rest call to search other users is disabled and the # form element is removed from the ui. alias-member-enabled = true webapp { # This is shown in the top right corner of the web application app-name = \"Sharry\" # The icon next to the app-name. Needs to be an URL to an image. app-icon = \"\" # The icon next to the app-name when dark mode is enabled. app-icon-dark = \"\" # The login and register pages display a logo image, by default # the Sharry logo. This can be changed here. It needs to be an URL # to an image. app-logo = \"\" # The login and register pages display a logo image. This is the # one used when dark mode is enabled. app-logo-dark = \"\" # This is markdown that is inserted as the footer on each page in # the ui. If left empty, a link to the project is rendered. app-footer = \"\" # Whether to display the footer on each page in the ui. Set it to # false to hide it. app-footer-visible = true # Chunk size used for one request. The server will re-chunk the # stream into smaller chunks. But the client can transfer more in # one requests, resulting in faster uploads. # # You might need to adjust this value depending on your setup. A # higher value usually means faster uploads (if the up-link is # good enough). It is set rather low by default, because it is a # safer default. chunk-size = \"10M\" # Number of milliseconds the client should wait before doing a new # upload attempt after something failed. The length of the array # denotes the number of retries. retry-delays = [0, 3000, 6000, 12000, 24000, 48000] # The login page can display a welcome message that is readable by # everyone. The text is processed as markdown. welcome-message = \"\" # The ISO-3166-1 code of the default language to use. If a invalid # code is given (or one where no language is available), it falls # back to \"gb\". default-language = \"gb\" # The interval a new authentication token is retrieved. This must # be at least 30s lower than `backend.auth.session-valid'. auth-renewal = \"4 minutes\" # The initial page to go to after logging in. It can be one of the # following: home, uploads, share initial-page = \"home\" # The value for the validity that is preselected. Only values that # are available in the dropdown are possible to specifiy. default-validity = 7 days # The inital ui theme to use. Can be either 'light' or 'dark'. initial-theme = \"light\" # When only OAuth (or only Proxy Auth) is configured and only a # single provider, then the weapp automatically redirects to its # authentication page skipping the sharry login page. This will # also disable the logout button, since sharry is not in charge # anyways. oauth-auto-redirect = true # A custom html snippet that is rendered into the html head # section of the main template. If the value is empty, a default # section is used for inserting a favicon configuration. # # The value is first tried to resolve to a file in the local file # system. If that is successful, it its content is being inserted # as utf8 characters. Otherwise the value given here is rendered # as is into the template! custom-head = \"\" } backend { # Authentication is flexible to let Sharry be integrated in other # environments. auth { # The secret for this server that is used to sign the authenicator # tokens. You can use base64 or hex strings (prefix with b64: and # hex:, respectively) server-secret = \"hex:caffee\" # How long an authentication token is valid. The web application # will get a new one periodically. session-valid = \"8 minutes\" #### Login Modules ## ## The following settings configure how users are authenticated. ## There are several ways possible. The simplest is to ## authenticate agains the internal database. But often there is ## already a user management component and sharry can be ## configured to authenticated against other services. # A fixed login module simply checks the username and password # agains the information provided here. This only applies if the # user matches, otherwise the next login module is tried. fixed { enabled = false user = \"admin\" password = \"admin\" order = 10 } # The http authentication module sends the username and password # via a HTTP request and uses the response to indicate success or # failure. # # If the method is POST, the `body' is sent with the request and # the `content-type' is used. http { enabled = false url = \"http://localhost:1234/auth?user={{user}}&amp;password={{pass}}\" method = \"POST\" body = \"\" content-type = \"\" order = 20 } # Use HTTP Basic authentication. An Authorization header using # the Basic scheme is created and the request is send to the # given url. The response body will be ignored, only the status # is inspected. http-basic { enabled = false url = \"http://somehost:2345/path\" method = \"GET\" order = 30 } # The command authentication module runs an external command # giving it the username and password. The return code indicates # success or failure. command { enabled = false program = [ \"/path/to/someprogram\" \"{{user}}\" \"{{pass}}\" ] # the return code to consider successful verification success = 0 order = 40 } # The internal authentication module checks against the internal # database. internal { enabled = true order = 50 } # Uses OAuth2 \"Code-Flow\" for authentication against a # configured provider. # # A provider (like Github, Google, or Microsoft for example) must be # configured correctly for this to work. Each element in the array # results into a button on the login page. # # Examples for Github, Google and Microsoft (Azure AD) are provided # below. You need to setup an “application” to obtain a client_secret # and client_id. # # Details: # - enabled: allows to toggle it on or off # - id: a unique id that is part of the url # - name: a name that is displayed inside the button on the # login screen # - icon: a fontawesome icon name for the button # - authorize-url: the url of the provider where the user can # login and grant the permission to retrieve the user name # - token-url: the url used to obtain a bearer token using the # response from the authentication above. The response from # the provider must be json or url-form-encdode. # - user-url: the url to finalyy retrieve user information – # only JSON responses are supported. # - user-id-key: the name of the field in the json response # denoting the user name # - user-email-key: the name of the field in the json response # that denotes the users email. oauth = { \"github\" = { enabled = false name = \"Github\" icon = \"fab fa-github\" scope = \"\" authorize-url = \"https://github.com/login/oauth/authorize\" token-url = \"https://github.com/login/oauth/access_token\" user-url = \"https://api.github.com/user\" user-id-key = \"login\" client-id = \"&lt;your client id&gt;\" client-secret = \"&lt;your client secret&gt;\" }, \"google\" = { enabled = false name = \"Google\" icon = \"fab fa-google\" scope = \"\" authorize-url = \"https://accounts.google.com/o/oauth2/v2/auth?scope=https://www.googleapis.com/auth/userinfo.profile\" token-url = \"https://oauth2.googleapis.com/token\" user-url = \"https://www.googleapis.com/oauth2/v1/userinfo?alt=json\" user-id-key = \"name\" client-id = \"&lt;your client id&gt;\" client-secret = \"&lt;your client secret&gt;\" }, \"aad\" = { enabled = false name = \"Azure AD\" icon = \"fab fa-microsoft\" scope = \"openid\" authorize-url = \"https://login.microsoftonline.com/&lt;your tenant ID&gt;/oauth2/v2.0/authorize\" token-url = \"https://login.microsoftonline.com/&lt;your tenant ID&gt;/oauth2/v2.0/token\" user-url = \"https://graph.microsoft.com/oidc/userinfo\" user-id-key = \"email\" user-email-key = \"email\" client-id = \"&lt;your client id&gt;\" client-secret = \"&lt;your client secret&gt;\" } } # Allows to inspect the request headers for finding already # authorized user name/email. If enabled and during login the # request contains these headers, they will be used to # automatically create accounts. proxy { enabled = false user-header = \"X-Valid-User\" email-header = \"X-User-Email\" } } # The database connection. # # By default a H2 file-based database is configured. You can # provide a postgresql or mariadb connection here. When using H2 # use the PostgreSQL compatibility mode. jdbc { url = \"jdbc:h2://\"${java.io.tmpdir}\"/sharry-demo.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" user = \"sa\" password = \"\" } # How files are stored. files { # The id of an enabled store from the `stores` array that should # be used. default-store = \"database\" # A list of possible file stores. Each entry must have a unique # id. The `type` is one of: default-database, filesystem, s3. # # All stores with enabled=false are # removed from the list. The `default-store` must be enabled. stores = { database = { enabled = true type = \"default-database\" } filesystem = { enabled = false type = \"file-system\" directory = \"/some/directory\" clean-empty-dirs = true } minio = { enabled = false type = \"s3\" endpoint = \"http://localhost:9000\" access-key = \"username\" secret-key = \"password\" bucket = \"sharry\" } } # Allows to copy files from one store to the other *before* sharry # will be available. It is recommended to set the `enabled` flag to # false afterwards and restart sharry. # # Files are only copied, they are *not* removed from the source # store. copy-files = { enable = false # A key in the `backend.files` config identifying the store to # copy from. source = \"database\" # A key in the `backend.files` config identifying the store to # copy the files to. target = \"minio\" # How many files to copy in parallel. parallel = 2 } } # Checksums of uploaded files are computed in the background. compute-checksum = { # Setting this to false disables computation of checksums completely. enable = true # How many ids to queue at most. If full, uploading blocks until # elemnts are taken off the queue capacity = 5000 # How many checksums to compute in parallel, must be &gt; 0. If 1, # they are computed sequentially. parallel = 0 # If true, the `parallel` option above is ignored and it will be # set to the number of available cores - 1 (using 1 for single # core machines). use-default = true } # Configuration for registering new users at the local database. # Accounts registered here are checked via the `internal' # authentication plugin as described above. signup { # The mode defines if new users can signup or not. It can have # three values: # # - open: every new user can sign up # - invite: new users can sign up only if they provide a correct # invitation key. Invitation keys can be generated by an admin. # - closed: signing up is disabled. mode = \"open\" # If mode == 'invite', this is the period an invitation token is # considered valid. invite-time = \"14 days\" # A password that is required when generating invitation keys. # This is more to protect against accidentally creating # invitation keys. Generating such keys is only permitted to # admin users. invite-password = \"generate-invite\" } share { # When storing binary data use chunks of this size. chunk-size = \"512K\" # Maximum size of a share. max-size = \"1.5G\" # Maximum validity for uploads max-validity = 365 days # Allows additional database checks to be translated into some # meaningful message to the user. # # This config is used when inspecting database error messages. # If the error message from the database contains the defined # `native` part, then the server returns a 422 with the error # messages given here as `message`. # # See issue https://github.com/eikek/sharry/issues/255 – the # example is a virus check via a postgresql extension \"snakeoil\". database-domain-checks = { # Example: This message originates from postgres with an # enabled snakeoil extension. This extension allows to virus # check byte arrays. It must be setup such that the `bytea` # type of the filechunk table is changed to the type # `safe_bytea`: # # CREATE EXTENSION pg_snakeoil; # CREATE DOMAIN public.safe_bytea as bytea CHECK (not so_is_infected(value)); # ALTER TABLE public.filechunk ALTER COLUMN chunkdata TYPE safe_bytea; snakeoil = { enabled = false native = \"domain safe_bytea violates check constraint\" message = \"The uploaded file contains a virus!\" } } } cleanup { # Whether to enable the cleanup job that periodically # cleans up published, expired shares and expired invites enabled = true # The interval for the cleanup job interval = 14 days # Time of published shares past expiration to get collected by cleanup job invalid-age = 7 days } mail { # Enable/Disable the mail feature. # # If it is disabled, the server will not send mails, including # notifications. # # If enabled, explicit SMTP settings must be provided. enabled = false # The SMTP settings that are used to sent mails with. smtp { # Host and port of the SMTP server host = \"localhost\" port = 25 # User credentials to authenticate at the server. If the user # is empty, mails are sent without authentication. user = \"\" password = \"\" # One of: none, starttls, ssl ssl-type = \"starttls\" # In case of self-signed certificates or other problems like # that, checking certificates can be disabled. check-certificates = true # Timeout for mail commands. timeout = \"10 seconds\" # The default mail address used for the `From' field. # # If left empty, the e-mail address of the current user is used. default-from = \"\" # When creating mails, the List-Id header is set to this value. # # This helps identifying these mails in muas. If it is empty, # the header is not set. list-id = \"Sharry\" } templates = { download = { subject = \"Download ready.\" body = \"\"\"Hello, there are some files for you to download. Visit this link: {{{url}}} {{#password}} The required password will be sent by other means. {{/password}} Greetings, {{user}} via Sharry \"\"\" } alias = { subject = \"Link for Upload\" body = \"\"\"Hello, please use the following link to sent files to me: {{{url}}} Greetings, {{user}} via Sharry \"\"\" } upload-notify = { subject = \"[Sharry] Files arrived\" body = \"\"\"Hello {{user}}, there have been files uploaded for you via the alias '{{aliasName}}'. View it here: {{{url}}} Greetings, Sharry \"\"\" } } } } } Logging Sharry logs to stdout. This works well, when managed by systemd or similar tools. Logging can be configured with these settings in the config file: logging.minimum-level specifies the log level to control the verbosity. Levels are ordered from: Trace, Debug, Info, Warn and Error logging.format this defines how the logs are formatted. There are two formats for humans: Plain and Fancy. And two more suited for machine consumption: Json and Logfmt. The Json format contains all details, while the others may omit some for readability levels optional logger name to level mappings to override the log level for specific loggers. If not mentioned here, everything is logged with minimum-level. The default sets some selected loggers to info and the others to warn."
    } ,    
    {
      "title": "Development",
      "url": "/sharry/doc/dev",
      "content": "Development Contribution Guide Lines Contribution guide lines may be found here. Building Clone the repository using git. git clone https://github.com/eikek/sharry Install Elm, Sbt, npm and the tailwind-cli, which is used to build the application. A convenient alternative is to install nix (with flakes enabled) and run nix develop in the project root. Even better with direnv which takes care of that step transitively. Start sbt in the source root and run inside the sbt shell: make to compile all sources (Elm + Scala) make-zip to create zip packages make-deb to create debian packages make-pkg to run a clean compile and create both packages The zip file can be found afterwards in: modules/restserver/target/universal/ The deb file is in modules/restserver/target/ Starting Servers with reStart When developing, it’s very convenient to use the revolver sbt plugin. Start the sbt console and then run: sbt:sharry-root&gt; restserver/reStart This starts a REST server. Prefixing the commads with ~, results in recompile+restart once a source file is modified. Note that with current sbt the revolver plugin will not restart the server if elm files are changed. But this is not really necessary: just run a second sbt shell with ~ compile and sbt will compile all elm files on change and the final js file is immediately available. Only a browser refresh is necessary to load the new web app. Custom config file The sbt build is setup such that a file local/dev.conf (from the root of the source tree) is picked up as config file, if it exists. So you can create a custom config file for development. For example, a custom database for development may be setup this way: #jdbcurl = \"jdbc:h2:///home/dev/workspace/projects/sharry/local/sharry-demo.db;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" #jdbcurl = \"jdbc:mariadb://localhost:3306/sharrydev\" jdbcurl = \"jdbc:postgresql://localhost:5432/sharrydev\" sharry.restserver { backend { jdbc { url = ${jdbcurl} user = \"dev\" password = \"dev\" } } } Nix Expressions The file flake.nix contains nix expressions to install sharry via the nix package manager and to integrate it into NixOS as a system service. Update the nix build The nix build is setup in flake.nix, which refers to the nix/package.nix to build the sharry application. It is build by first obtaining all dependencies, so that the actual build can be done in a sandbox without network. Since npm and elm mess with the users home directory and require an internet connection, building the webapp into a webjar is done as part of the “dependency phase”. If something changes, run nix build twice and check whether the hash is the same (this to check whether there was something not reproducible accidentally included). Then update the depsSha256 attribute in package.nix. Run nix build again and start the app for a quick check. NOTE: if nix has the dependencies with the given hash cached, it will not build it again. To be sure, just remove the hash and leave an empty string. The build will then fail and give the proper hash. Testing NixOS Modules The modules can be build by building the configuration-test.nix file which is referenced in the flake. nixos-rebuild build-vm --flake .#test-vm To build and run with one command: nix run .#nixosConfigurations.test-vm.config.system.build.vm This will build, resp. run, a vm with sharry included. After the build-vm command completes, the system configuration can be found behind the ./result/system symlink. So it is possible to look at the generated systemd config for example: cat result/system/etc/systemd/system/sharry.service And with some more commands (there probably is an easier way…) the config file can be checked: cat result/system/etc/systemd/system/sharry.service | \\ grep ExecStart | \\ cut -d'=' -f2 | \\ xargs cat | \\ tail -n1 | \\ sed 's/sharry.restserver = //' | \\ jq To see the module in action, the vm can be started (the first line sets more memory for the vm): export QEMU_OPTS=\"-m 2048\" ./result/bin/run-sharrytest-vm"
    } ,    
    {
      "title": "Fail2ban",
      "url": "/sharry/doc/fail2ban",
      "content": "Fail2ban This contains examples for how to use sharry with fail2ban. fail2ban is a tool to detect brute force authentication attempts and ban offenders from any further attempts. It continuously reads the logs for lines that fit a regex and parses the ip address of the offender from the line. Fail2ban requires a jail and filter to be defined. The filter will define which log lines are considered lines detailing failed authentication attempts and where the ip address may be parsed. The jail will define which iptables chain and names should be used to ban the offending ip address in and which ports the offender will be banned for. It also defines how many authentication attempts an ip may try before it is considered an offender, how long the offender is banned for and the (time) window of log lines is considered while searching for offenders. An example jail config: [sharry] enabled = true port = 0:65535 filter = sharry action = iptables-allports[actname=name=sharry-in, name=sharry-in, chain=INPUT] iptables-allports[actname=sharry-fw, name=sharry-fw, chain=FORWARD] logpath = /path/to/your/sharry-logging-file maxretry = 3 bantime = 10m findtime = 1h An example filter config: [Definition] failregex = Authentication attempt failure for username .* from ip &lt;ADDR&gt; Password challenge failure for share id .* from ip &lt;ADDR&gt; No share with id .* Attempt by ip &lt;ADDR&gt; ignoreregex ="
    } ,    
    {
      "title": "Documentation",
      "url": "/sharry/doc/",
      "content": "Sharry Sharry allows to share files with others in a simple way. It is a self-hosted web application. The basic concept is: upload files and get a url back that can then be shared. How it works Authenticated users → others Authenticated users can upload their files on a web site together with an optional password and a time period. The time period defines how long the file is available for download. Then a public URL is generated that can be shared, e.g. via email, with everyone. While the download page is hard to guess, everyone who knows it can access the files. Others → Authenticated users Anonymous can send files to registered users. Each registered user can maintain alias pages. An alias page is also behind a “hard-to-guess” URL (just like the download page) and allows everyone to upload files to the corresponding user. The user belonging to the alias can be notified via email. Features Both ways: Receive and send files to/from anonymous users. Integration: Sharry aims to be easy to integrate in other environments. Authentication: There are many ways to authenticate users from different sources and/or use internal user management. REST Api exposing all the features, making it available for scripts. Reliable up- and downloads Uploads: While the server accepts standard multipart requests, it also supports the tus protocol allowing for resumable uploads. In case network goes down in the middle of uploading a large file, simply upload the same file again and it will start where it left off. Downloads: Using ETag and range requests allows the clients (the browser, mostly) to cache files and to download only portions of files. This makes it possible to efficiently view videos in the browser (being able to click into the timeline). Web client for managing and accessing shares. Signup Let all users create new accounts, only invited ones or none. Restrict public download pages using three properties: a lifetime, a password (acting as a second secret) and download-limit. Periodic cleanup will remove expired shares Send E-Mails from within Sharry (if configured) DBMS Data is stored in a relational database, supporting PostgreSQL, MariaDB and H2 (h2 is an in-process db, not requiring a separate database server). Files can be stored in the database as well. Other options are the filesystem or an S3 compatible object storage License This project is distributed under the GPLv3+"
    } ,      
    {
      "title": "Installation",
      "url": "/sharry/doc/install",
      "content": "Installation This page contains detailed installation instructions. For a quick start, refer to this page. Sharry is a REST Server that also provides the web application. The web application runs in the browser and talks to the server using the REST Api. The download page provides pre-compiled packages and the development page contains build instructions. Prerequisites Java Very often, Java is already installed. You can check this by opening a terminal and typing java -version. Otherwise install Java using your package manager or see this site for other options. It is enough to install the JRE. The JDK is required, if you want to build sharry from source. Sharry has been tested with Java version 17. The pre-build packages are also build using JDK 17. But a later version of Java should work as well. Database Sharry stores all its information (files, accounts etc) in a database. The following products are supported: PostreSQL MariaDB H2 The H2 database is an interesting option for personal and mid-size setups, as it requires no additional work (i.e. no separate db server). It is integrated into sharry and works really well. It is also configured as the default database. For large installations, PostgreSQL or MariaDB is recommended. Create a database and a user with enough privileges (read, write, create table) to that database. When using H2, make sure to add the options ;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE at the end of the url. See the default config for an example. Installing from ZIP files After extracting the zip files, you’ll find a start script in the bin/ folder. Installing from DEB packages The DEB packages can be installed on Debian, or Debian based Distros: $ sudo dpkg -i sharry*.deb Then the start scripts are in your $PATH. Run sharry-restserver from a terminal window. The packages come with a systemd unit file that will be installed to autostart the services. Running Run the start script (in the corresponding bin/ directory when using the zip files): $ ./sharry-restserver*/bin/sharry-restserver This will startup using the default configuration. The configuration should be adopted to your needs. For example, the database connection is configured to use a H2 database that is created in the /tmp directory. Please refer to the configuration page for how to create a custom config file. Once you have your config file, simply pass it as argument to the command: $ ./sharry-restserver*/bin/sharry-restserver /path/to/server-config.conf After starting the rest server, you can reach the web application at path /app, so using default values it would be http://localhost:9090/app. The root path, http://localhost:9090/, redirects to this url. You should be able to create a new account and sign in. Options The start scripts support some options to configure the JVM. One often used setting is the maximum heap size of the JVM. By default, java determines it based on properties of the current machine. You can specify it by given java startup options to the command: $ ./sharry-restserver*/bin/sharry-restserver -J-Xmx1G -- /path/to/server-config.conf This would limit the maximum heap to 1GB. The double slash separates internal options and the arguments to the program. Another frequently used option is to change the default temp directory. Usually it is /tmp, but it may be desired to have a dedicated temp directory, which can be configured: $ ./sharry-restserver*/bin/sharry-restserver -J-Xmx1G -Djava.io.tmpdir=/path/to/othertemp -- /path/to/server-config.conf The command: $ ./sharry-restserver*/bin/sharry-restserver -h gives an overview of supported options. System properties All options that are given with -D are called system properties. These can be used to overwrite certain configuration values. System properties always take precedence over values defined in config files. This can be handy to temporarily change some configuration, for example, enable the fixed admin account like this: $ ./sharry-restserver*/bin/sharry-restserver -Dsharry.restserver.backend.auth.fixed.enabled=true -- /path/to/server-config.conf"
    } ,      
    {
      "title": "Migration",
      "url": "/sharry/doc/migration",
      "content": "Migration NOTE: This migration has been available for 2 years and was removed in version 1.10.0. Should you need it, please use a version prior to 1.10.0 to run the migration from 0.6.x. After this you can start the newest version. For users of Sharry version 0.6.x, the database schema must be migrated (kind of) manually. The application doesn’t do it automatically. However, there is a built-in script that converts the old schema into the new one. But: At first, please backup the data. If you don’t care, then its probably easier to just start with a new database :). When migrating from Sharry version &lt; 0.6.x, you’ll need first to run a 0.6 version against the database. This will evolve the db schema to the point where the migration-script from 1.0 can take it further. Then follow this guide. Postgres and MariaDB For these databases, you can start the restserver binary with a special option -Dsharry.migrate-old-dbschema=true. ./sharry-restserver-1.15.0/bin/sharry-restserver -Dsharry.migrate-old-dbschema=true ./sharry-new.conf This will not start the restserver but rather run the migration against the database configured in given config file. If that completes successfully, you can startup sharry as normal (without that option). H2 H2 is a little more involved. This is because the database initialization changed and the parameters given with the URL cannot be changed afterwards. The steps are roughly this: create a dump change the dump to make it postgres compatible import it into a new database (using the new connection settings) run the migration from above Dump The dump can be created using a tool provided by h2: Script (doc). It is in the jar file that is on your disk if you have sharry installed. So the dump can be created like this: java -cp sharry-restserver-1.15.0/lib/com.h2database.h2-1.4.200.jar org.h2.tools.Script -url \"jdbc:h2:///var/data/sharry/sharry-old-db\" -user sa -password \"\" This will create a backup.sql file in the current directory. Change the Dump This dump uses some incompatible things: all identifiers are upper case and the datatype for a blob is called bytea in postgres. This can be changed with GNU Sed: sed -i 's,\"CHUNKDATA\" BLOB NOT NULL,\"CHUNKDATA\" BYTEA NOT NULL,g' backup.sql sed -i 's,\"[_A-Z]*\",\\L&amp;,g' backup.sql The first command fixes the datatype thing and the second converts all words in quotes into lowercase. Note: for the second command, the GNU version of Sed is required. Import the Dump Now the changed dump must be imported into a new database. Since h2 creates one on demand, just run the command and specify now the new connection – to an unexisting file and with the required settings MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE. Again, a tool from h2 can be used (RunScript, doc): java -cp sharry-restserver-1.15.0/lib/com.h2database.h2-1.4.200.jar org.h2.tools.RunScript -url \"jdbc:h2:///var/data/sharry/sharry-newdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE\" -user sa -password \"\" Migrate Now run sharry with the migration setting as described above for Postgres and MariaDB."
    } ,    
    {
      "title": "Nix/NixOS",
      "url": "/sharry/doc/nix",
      "content": "Nix/NixOS Install nix Sharry is a flake. You need to enable flakes in order to make use of it. You can also use the provided expressions without Flakes, which is described below. Try it out You can try out sharry by running the following: nix run github:eikek/sharry To pass a configuration file, provide it to the command after a double-dash: nix run github:eikek/sharry -- /path/to/sharry.conf This will run the latest release using a file-based database in the /tmp directory. A more elaborate setup can be started using the test-vm: nix run github:eikek/sharry#nixosConfigurations.test-vm.config.system.build.vm This starts a VM with sharry installed connected to a PostgreSQL database. Install via Nix Sharry can be installed via the nix package manager. Sharry is currently not part of the nixpkgs collection, but you can use this flake. $ nix profile install github:eikek/sharry Latest Release The flake provides two packages: sharry-dev is build from the source tree as referenced by the flake url. The package sharry builds the latest (at time of the commit referenced by the flake url) release as published to GitHub. The NixOS module uses the sharry package by default. It can be changed via the config to provide a different one. Sharry as a service on NixOS If you are running NixOS, there is a module definition for installing Sharry as a service using systemd. Define this repo in your inputs and refer to its module: { inputs = { sharry = \"github:eikek/sharry\"; }; outputs = attrs@{ nixpkgs, sharry, ... }: { nixosConfigurations.my-machine = nixpkgs.lib.nixosSystem { system = \"x86_64-linux\"; specialArgs = attrs; modules = [ # include sharry sharry.nixosModules.default # your machine config ./configuration.nix ]; }; }; } Please see the nix/module.nix file for the set of options. The nixos options are modelled after the default configuration file. Without Flakes You can use the provided nix expressions without flakes. The default package is in nix/package-bin.nix. Just call them with your nixpkgs instance as usual: let repo = fetchFromGitHub { owner = \"eikek\"; repo = \"sharry\"; rev = \"master\"; sha256 = \"sha256-/tBvn1l8XUCsNyed4haK9r6jwc1uTCxag4qYv0ns0qs=\"; }; sharry = callPackage (import \"${repo}/nix/package-bin.nix\") {}; in …"
    } ,    
    {
      "title": "Quickstart",
      "url": "/sharry/doc/quickstart",
      "content": "Quickstart To quickly try out sharry, follow these steps: Download a zip (version 1.15.0) from the release page. e.g. sharry-restserver-1.15.0.zip Unpack it to some place. $ unzip sharry-restserver-1.15.0.zip Run the executable: $ /path/to/extracted-zip/bin/sharry-restserver Goto http://localhost:9090/, signup and login If you want to know more, for example what can be configured, checkout these pages. Quickstart with Docker There is a docker-compose setup available in the /docker folder. Clone the github repository $ git clone https://github.com/eikek/sharry Change into the docker directory: $ cd sharry/docker Run docker-compose up: $ docker-compose up Goto http://localhost:9090/, signup and login The directory contains a file sharry.conf that you can modify as needed."
    } ,    
    {
      "title": "Rest Api",
      "url": "/sharry/doc/rest",
      "content": "REST Api Sharry is provided as a REST server and a web application client. The REST Api is specified using openapi 3.0 and it’s static documentation can be seen here. The “raw” openapi.yml specification file can be found here. The calls are divided into 4 categories: /open/*: no authentication is required to access /sec/*: an authenticated user is required /alias/*: these routes are allowed with a valid alias id given as header Sharry-Alias /admin/*: an authenticated user that is admin is required Authentication works by logging in with username/password (or an oauth2 flow) that generates a token that has to be sent with every request to a secured and admin route. It is possible to sent it via a Cookie header or the special Sharry-Auth header. Files can be uploaded using different methods. There is an endpoint that can take all files and meta data from one single request. For more reliable uploads, the server implements the tus protocol that allows to resume failed or paused uploads. Authentication The unprotected route /open/auth/login can be used to login with account name and password. The response contains a token that can be used for accessing protected routes. The token is only valid for a restricted time which can be configured (default is 5 minutes). New tokens can be generated using an existing valid token and the protected route /sec/auth/session. This will return the same response as above, giving a new token. This token can be added to requests in two ways: as a cookie header or a “normal” http header. If a cookie header is used, the cookie name must be sharry_auth and a custom header must be named Sharry-Auth. Live Api Besides the statically generated documentation at this site, the rest server provides a openapi generated documenation, that allows playing around with the api. It requires a running sharry rest server. If it is deployed at http://localhost:9090, then check this url: http://localhost:909/api/doc Examples Login with username/password $ curl -d'{\"account\":\"eike\", \"password\":\"test\"}' http://localhost:9090/api/v2/open/auth/login Output: {\"id\":\"6ExuF2eYpvd-hFPyEk4jAdy-aGiyyyDRk3q-nHkAE6kjViU\",\"user\":\"eike\",\"admin\":false,\"success\":true,\"message\":\"Login successful\",\"token\":\"1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=\",\"validMs\":300000} The token must be used with subsequent requests. It is valid for 5 minutes. Get a new token $ curl -XPOST -H 'Sharry-Auth: 1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=' http://localhost:9090/api/v2/sec/auth/session Output: {\"id\":\"6ExuF2eYpvd-hFPyEk4jAdy-aGiyyyDRk3q-nHkAE6kjViU\",\"user\":\"eike\",\"admin\":false,\"success\":true,\"message\":\"Login successful\",\"token\":\"1577122497189-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$9/VNIq8e3YxHKTLyE0JwbO-bI0CpZnEsmfhDHxsjwhe7qzQaSY=\",\"validMs\":300000} Get your shares $ curl -XGET -H 'Sharry-Auth: 1577122333196-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$t5OpvGG8/t0.Dw2CO3RSN.-Lnow8nTb4t9nVMBkJEJbaRwABGY=' http://localhost:9090/api/v2/sec/share/search Output: {\"items\":[{\"id\":\"7wNPzKepw4g-gKgSfQ376tJ-HSifxLc33r5-xY8FigeF7wG\",\"name\":null,\"aliasName\":null,\"validity\":172800000,\"maxViews\":30,\"password\":false,\"created\":1577102005295,\"files\": 1,\"size\":199640,\"published\":null},{\"id\":\"44EPQPe7Lo2-KnUCp3kiQNg-dJ4oxiAQ5Lh-etMiDwe5KD3\",\"name\":null,\"aliasName\":null,\"validity\":172800000,\"maxViews\":30,\"password\":false,\"created \":1577101969643,\"files\":1,\"size\":192886,\"published\":null}]} Create an alias page $ curl -XPOST -H 'Sharry-Auth: 1577122785983-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$kceo1M6cRNpMpptb0F67uO-sZurk/s03VHuzpxLGhT+AUF4TjU=' -d'{\"name\":\"test alias\",\"validity\": 172800000, \"enabled\":true,\"members\":[]}' http://localhost:9090/api/v2/sec/alias Output: {\"success\":true,\"message\":\"Alias successfully created.\",\"id\":\"HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV\"} Upload a file to the new alias page Using the id, upload files via multipart/form-data requests. You can upload multiple files at once. $ curl -XPOST -F file=@P1020416.JPG -F file=@P1020422.JPG -H 'Sharry-Alias: HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV' http://localhost:9090/api/v2/alias/upload Output: {\"success\":true,\"message\":\"Share created.\",\"id\":\"8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8\"} Get Details about the share This requires authenticated users, of course. The | jq pipes the one-line json output through a program that formats it. $ curl -H'Sharry-Auth: 1577132299230-NkV4dUYyZVlwdmQtaEZQeUVrNGpBZHktYUdpeXl5RFJrM3EtbkhrQUU2a2pWaVUvZWlrZS9mYWxzZQ==-$2a$10$jFhOEGYktHb8yiLF5mhHjO-CvDL2MniUH+RQv8dTSWPwhSUeIw=' http://localhost:9090/api/v2/sec/share/8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8 | jq Output: { \"id\": \"8P7GzxmLGjF-F7K4kXAhe8j-6AhLrQuFJGb-i54TTRZ3xn8\", \"name\": null, \"aliasId\": \"HfHViHEN5EM-E6jmgmw1W3H-KVUR2KanbEd-EGvDeZR2RPV\", \"aliasName\": \"test alias\", \"validity\": 172800000, \"maxViews\": 30, \"password\": false, \"descriptionRaw\": null, \"description\": null, \"created\": 1577132473544, \"publishInfo\": null, \"files\": [ { \"id\": \"6QcXQ9qeSQb-VYF2p9M23XT-bMPRFkmtsPK-ejjJUns3Ymk\", \"filename\": \"P1020416.JPG\", \"size\": 2829079, \"mimetype\": \"image/jpeg\", \"checksum\": \"8ffe8da9d49b7e6590b78362ed0acd4156f4bccaa724c710560a57bd3c54d74d\", \"storedSize\": 2829079 }, { \"id\": \"Eur8FJj4uxL-q9NYVBqYi1L-jnsEFKPwCYQ-6Z81iazysjD\", \"filename\": \"P1020422.JPG\", \"size\": 3692609, \"mimetype\": \"image/jpeg\", \"checksum\": \"424bcfa141f61a73269466102ee1a826f1fae31a847a5861500fc4cbdfb1732f\", \"storedSize\": 3692609 } ] } The output contains the two files that have been uploaded. Also interesting is the storedSize property. This indicates how many bytes really reached the server. The size property uses the value as advertised by the uploader. If storedSize does not equal size then the file is not fully uploaded."
    } ,    
    {
      "title": "Reverse Proxy",
      "url": "/sharry/doc/reverseproxy",
      "content": "Reverse Proxy This contains examples for how to use sharry behind a reverse proxy. For the examples below, assume the following: Sharry app is available at 192.168.1.11:9090. The external domain/hostname is sharry.example.com Configuring Sharry These settings require a complement config part in the sharry configuration file: First, if Sharry REST server is on a different machine, you need to change the bind.address setting to be either 0.0.0.0 or the ip address of the network interface that the reverse proxy server connects to. sharry.restserver { # Where the server binds to. bind { address = \"192.168.1.11\" port = 9090 } } Note that a value of 0.0.0.0 instead of 192.168.1.11 will bind the server to every network interface. If it is running on the same machine as the reverse proxy server, you can set localhost instead. Sharry needs to know the external url. The base-url can be used to explicitely specify this url. If it is left at its default value, sharry finds the external url from the request. It is recommended to set this url, if you have a single external url. Using above values, it must be set to https://sharry.example.com. sharry.restserver { # This is the base URL this application is deployed to. This is used # to create absolute URLs and to configure the cookie. # # Note: Currently deploying behind a path is not supported. The URL # should not end in a slash. base-url = \"https://sharry.example.com\" ... } The maximum request size should probably be increased at the reverse proxy. This depends on your machine, of course. The sharry related setting is sharry.restserver.webapp.chunk-size. This defines the size that is used for uploading chunks of data in one request. sharry.restserver { webapp { # Chunk size used for one request. The server will re-chunk the # stream into smaller chunks. But the client can transfer more in # one requests, resulting in faster uploads. # # You might need to adjust this value depending on your setup. A # higher value usually means faster uploads. chunk-size = \"100M\" } Here a chunk-size of 100M is used and the reverse proxy must be set to at least this value. Below it is set to 105M, just to be sure. If you have examples for more servers, please let me know or add it to this site. Nginx This defines two servers: one listens for http traffic and redirects to the https variant. Additionally it defines the let’s encrypt .well-known folder name. For more information about how to setup let’s encrypt, please refer to their documentation and/or the nginx documentation. The https server endpoint is configured with the let’s encrypt certificates and acts as a proxy for the application at 192.168.1.11:9090. The setting client_max_body_size is relevant, too. This is the maximum size of a single requests. This must be greater than sharry’s webapp.chunk-size setting. The setting proxy_buffering off; disables buffering responses from the application coming to nginx. Buffering may introduce backpressure problems if the client is not reading fast enough. The response coming from the application may quickly be too large to fit in memory and nginx then writes a temporary file (which is limited to 1G by default). If this limit is reached, nginx waits until the client has received all disk buffered data which in turn can result in send timeouts. http { map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 0.0.0.0:80 ; listen [::]:80 ; server_name subdomain.otherdomain.tld ; location /.well-known/acme-challenge { root /var/data/nginx/ACME-PUBLIC; auth_basic off; } location / { return 301 https://$host$request_uri; } } server { listen 0.0.0.0:443 ssl http2 ; listen [::]:443 ssl http2 ; server_name sharry.example.com ; location /.well-known/acme-challenge { root /var/data/nginx/ACME-PUBLIC; auth_basic off; } ssl_certificate /var/lib/acme/sharry.example.com/fullchain.pem; ssl_certificate_key /var/lib/acme/sharry.example.com/key.pem; ssl_trusted_certificate /var/lib/acme/sharry.example.com/full.pem; location / { proxy_pass http://192.168.1.11:9090; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; } } } Serving two domains This config shows an example to serve nginx on two domains, while the sharry app is fixed to one domain. This will allow to always use the same base-url in e-mail templates, while serving the webapp on different domains. This is in contrast to the default behaviour (leaving base-url setting to its default): the url in mail templates would change according to the request. # sharry.conf: base-url = \"https://example.org\" map $http_upgrade $connection_upgrade { default upgrade; '' close; } # this is the domain as configured in sharry, serve as is server { listen [::]:443 ssl default_server; server_name example.org; root /srv/http; location / { # This is the nginx example from the sharry docs proxy_pass http://localhost:9090/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; } } # this is the second domain as configured in sharry, do the replacing server { listen [::]:80 default_server; server_name example.com; root /srv/http; location / { # This is the nginx example from the sharry docs proxy_pass http://localhost:9090/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_buffering off; client_max_body_size 105M; proxy_send_timeout 300s; proxy_read_timeout 300s; send_timeout 300s; # Replace the protocol/domain in Location headers proxy_redirect https://example.org/ http://example.com/; # Replace the protocol/domain in the content sub_filter_once off; sub_filter \"https://example.org\" \"http://example.com\"; sub_filter \"example.org\" \"example.com\"; # sub_filter does not work with gzip, so enforce plaintext # see https://www.nginx.com/resources/wiki/modules/substitutions/#subs-filter-types proxy_set_header Accept-Encoding \"\"; } }"
    } ,    
    {
      "title": "Screenhots",
      "url": "/sharry/doc/screenshots",
      "content": "Screenshots These are some screenshots to get a little impression of the web client. It might be outdated, though. Home Screen Uploading a file View Share Details View Link to public page View Files View Files with preview Preview a single file Mobile View"
    } ,      
    {
      "title": "ShareX",
      "url": "/sharry/doc/sharex",
      "content": "{{ page.title }} ShareX is a popular screenshot tool. Below is a “custom upload” template to allow uploading screenshots to Sharry from ShareX. { \"Version\": \"1.3.1\", \"DestinationType\": \"ImageUploader, TextUploader, FileUploader\", \"RequestMethod\": \"POST\", \"RequestURL\": \"https://your.sharry/api/v2/alias/upload\", \"Body\": \"MultipartFormData\", \"Headers\": { \"Sharry-Alias\": \"some-alias-id\" }, \"FileFormName\": \"file[]\", \"URL\": \"https://your.sharry/app/upload/$json:id$\" } You need to replace http://your.sharry with your sharry url and specify some alias id, replacing some-alias-id in the example. The alias id can be found at any alias page that you have access to."
    } ,    
    {
      "title": "Webapplication",
      "url": "/sharry/doc/webapp",
      "content": "Webapplication The web client is written in Elm. The tus javascript client library is used to realize the resumable uploads. All the css is provided by TailwindCSS. Creating a new share After logging in, you can create new shares: The details are all optional and can also be changed afterwards. It is required to specfiy a description, some files or both. Otherwise submitting won’t work. The detail options are explained below. Name A share may have a name. This name is mainly meant for the owner to helps finding shares easier in the list view. The name will also be used as the head line, if the description doesn’t contain a markdown headline (a line starting with #). In that case, users who access the published site, will see it. Description You can add some text to a share which will be displayed at the download page. The description can be markdown and is converted to HTML when being displayed. Furthermore, the description text is processed as a mustache template and allows to refer to the attached files. You can access the following properties of any uploaded file: id filename url mimetype size length checksum The size is the file size as a human readable string, while length is the number in bytes. You can refer to files using their name or index in the list. When using the file name, all dots in there must be removed. {% raw %} {{#file.0}}{{url}}{{/file.0}} {% endraw %} or {% raw %} {{filename.dsc0100JPG.url}} {% endraw %} This makes it possible to embed files in the description, for example to display an image file, you could write the following description: {% raw %} ![an image]({{filename.DSCF0343JPG.url}}) {% endraw %} There is also a files property that can be used to iterate through all uploaded files. So this would render the id and url of all files: {% raw %} {{#files}} - {{id}}: {{url}} {{/files}} {% endraw %} Validity Time Every upload has a validity time after which the uploaded files are “expired”. Then the public download page is not visible anymore and the files can’t be downloaded from non-protected urls. The files are there and the user that owns them still has access. They are eventually removed by a cleanup job. Password The files can be further protected by a password. The download page requires this password in order to download the files. The idea is that this password is a second secret, next to the url. You can share the URL using one channel (maybe e-mail) and the password using another channel. A person must have both things in order to see the files. Maximum Views This setting restricts the number of accesses to the download page. If the download page is accessed more than this number, it will not work anymore. Publish / Unpublish / Republish A share that has not been published can only be accessed by its owner. In order to create a link for everyone else, click the Publish button in the top right of the detail view of a share. Once a share is published that circle is green. The expiry time is calculated from the validity time added to the point in time the share is publshed. You’ll see it in the details pane. If the share is published you can get the link clicking on the Share Link pane. You can copy&amp;paste it, scan the QR code or send it via e-Mail (if sharry is configured for that, it can be sent directly in the webapp). You can unpublish a share at any time. The public link will immediately stop working and the circle will be empty. Then there are two options for publishing it again: one will generate a new random link, the other option reuses the current public link. If you hit the Publish button in the top right corner again, the share will be published anew – meaning the current validity time is added to the current point in time, but the public link will not change. All people that you have shared it with earlier can immediately open the site again. If you rather like to publish it to a new URL, click the black publish button at the bottom of the Detail pane (see the screenshot below). Edit Details The share properties can be changed in the detail view of a share. The detail view consists of a top menu, then follows the description, then the file list menu and finally the list of files. Open the Detail tab in the top menu to see all properties. Properties that have the little blue edit icon in front of their names can be changed by clicking that icon. The description can be edited by clicking the edit icon next to the Publish button in the top right corner. It is also possible to add or remove files of that share. Click the right menu item of the file list menu and the upload form appears. Alias Pages The alias page is a way to let other users upload files for you. The idea is the same as with shared downloads: there is a cryptic URL you can share with others. This url allows to upload files that will be associated to the owner of that alias page. Click in the top right menu that opens a drop down menu and choose Aliases. There you can create, edit and remove alias pages. Alias pages are also convenient for quickly uploading files for yourself, as they don’t require any authentication. For example, using curl you could do: $ curl -H'Sharry-Alias: E5EohHtJHxN' -F file=@test.jpg -F file=@logo.jpg http://localhost:9090/api/v2/alias/upload {\"success\":true,\"message\":\"Share created.\",\"id\":\"FDQvHK2LVGe-SjkDjQxMiSo-8fPyBqKX3AY-nmWWnDsrRX3\"} See the REST page for more details on the various routes. Alias Members An alias can specify a list of users that are then members of that alias. This allows to give access to all uploads through this alias to the members. Every member can edit/delete/publish etc the shares that are created via the corresponding alias. While all members can see the alias and manage corresponding uploads, editing its properties is only possible by its creator. This may be useful to give a group of people access to the same files and to make it simpler to share files among registered users."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
